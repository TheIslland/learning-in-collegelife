# 数据结构学习笔记

## 1.什么是数据结构？

**数据结构　＝　结构定义　＋　结构操作**

## 什么是数据结构？**数据结构** 是计算机存储、组织数据的方式，是指数据元素的集合以及数据元素之间存在的一种或者多种关系的集合，元素之间的关系包括数据的逻辑结构、数据的存储结构和数据的运算结构。

**数据** 是信息的载体，是可以被计算机识别存储并加工处理的描述客观事物的信息符号的总称。

**数据元素** 是数据的基本单位，在计算机程序中通常作为一个整体考虑。一个数据元素由若干个 **数据项** 组成。数据项是数据结构中讨论的最小单位。有两类数据元素：如果数据元素不能再分，则称为**原子项**；如果数据元素由若干个数据项组成，则称为**组合项**。

## 2.数据结构分类

数据结构有两个要素，一个是数据元素的集合，另一个是关系的集合。在形式上，数据结构通常可以采用一个二元组来表示。数据结构按数据元素之间关系的不同，可以分为以下四类基本结构：

集合结构。数据元素属于同一个集合。

线性结构。数据元素之间存在着一对一的关系。常见的有链表、队列、栈等。

树形结构。数据元素之间存在着一对多的关系。常见的有二叉树、二叉查找树、平衡二叉查找树等。

图形结构。数据元素之间存在着多对多的关系。

按照存储方式的不同，数据结构可以分为顺序存储结构和链式存储结构：

顺序存储结构，表示数据元素在存储器中是连续存储的，可以用相对位置来表示数据元素之间的逻辑结构，如顺序表、队列、栈等。

链式存储结构，每个数据元素里设置了一个指针用来指向另一个元素的存储地址，以此来表示数据元素之间的逻辑结构。

按照逻辑结构来分，数据结构可以分为线性结构和非线性结构，如果数据元素之间存在一对一的关系，则称为线性结构，否则称为非线性结构。集合结构、树形结构、图形结构都称为非线性结构。

## 3.算法

算法（Algorithm）是对某一个或者某一类问题的解决方案的描述，根据问题的输入，在有限的计算时间里输出预期的结果。不同的算法解决问题所需的时间和空间可能会不同，通常用时间复杂度和空间复杂度来评估算法的优劣。

算法有以下5个特征：

有穷性。算法必须在执行有限个操作后终止。

确切性。算法的每一个操作必须有明确的定义。

输入项。算法有零个或多个输入，描述算法的初始状态。

输出项。算法有一个或多个输出，没有输出的算法我们认为是没有意义的。

可行性。算法的每个计算操作都可以在有限时间内完成。

**数据结构和算法之间有什么关系呢？**

数据结构描述了数据元素之间的逻辑关系，算法描述了数据元素的操作步骤，数据结构和算法组成了程序世界。数据结构和算法之间是不可分割的关系，数据结构是程序的基础，算法将数据互相联系起来，形成了一套能解决具体问题的方案。

在解决问题时，一般我们会优先确定数据结构，然后再来完善算法，有时也会反过来，根据算法来选择合适的数据结构。选择一个合适的数据结构，可以降低算法的复杂度，提高算法的效率。

## 4.复杂度分析

算法的复杂度是评估算法性能优劣一个重要的指标，可以帮助程序员估算出算法在执行之后所需要的时间和空间，所以分析算法的复杂度几乎成了每个程序员必须掌握的能力。

算法的复杂度分为算法的时间复杂度和空间复杂度。在介绍时间复杂度之前，我们需要引入 时间频度 的概念。时间频度是指算法中语句的执行次数，用 **T(n)** 来表示，**n**为问题的规模。

有些时候，时间频度的表达方法有点复杂，我们需要更直观的表达方法，于是引入了时间复杂度的概念。如果有一个辅助函数 **f(n)**，在 **n** 趋向于无穷大时，**T(n)/f(n)**的极限值为不等于 **0**的常数，则我们近似的将 **f(n)** 替代 **T(n)**，记为 **T(n) =O(f(n))**，称为算法的渐进时间复杂度。

时间复杂度只关心算法中最耗时的部分，舍去常数部分，通常用简单的函数来表示。例如，某算法计算出来

 **T(n) = 2n^3^ + 4n^2^ + n**，则它的时间复杂度为 **O(n^3^)**。按效率从高到低排列，时间复杂度一般有以下几种：



| 常数阶   | 对数阶        | 线性阶   | 线性对数阶   | 平方阶      | 立方阶      | 指数阶      | 阶乘阶    |
| -------- | ------------- | -------- | ------------ | ----------- | ----------- | ----------- | --------- |
| **o(1)** | **o(log~n~)** | **o(n)** | **o(nlogn)** | **o(n^2^)** | **o(n^3^)** | **o(2^n^)** | **o(n!)** |



我们举个例子来描述下算法时间复杂度的计算过程。现有如下代码，可以计算出语句 1 执行了 **n^2^**次，语句 2 执行了 **n** 次，语句 3 执行了 **logn** 次，则 **T(n) = n^2^ + n + logn**，取其中最耗时部分，并用熟悉的函数表示，则时间复杂度为**O(n^2^)**。

```c
for (int i = 0; i < n; i++) {
    for (int j = 0; j < n; j++) {
        a++; //1
    }
}
for (int i = 0; i < n; i++) {
    b++; //2
}
while (n) {
    n = n / 2; //3
}
```



算法的空间复杂度是指运行该算法所占用的存储空间大小，记为 **S(n)**，和时间复杂度类似，通常也是取它的渐进空间复杂度，用一个直观的函数来表示。通过空间复杂度，我们可以预估出算法运行所需的存储空间，包括指令空间、数据空间、动态申请的内存空间等。

有如下代码，可以计算出 **S(n) = n + n^2^**，则空间复杂度为**O(n^2^)**。

```c
int *a = new int[n];
int **b = new int*[n];
for (int i = 0; i < n; i++) {
    b[i] = new int[n];
}
```



##  5.线性表

线性表是由 **相同数据类型** 的 n 个数据元素 **a~0~,a~1~ ... a~n-1~**组成的有限序列。一个数据元素可以由若干个数据项组成。若用 L 命名线性表，则其一般表示如下：**L=(a~0~, a~1~, ..., a~n-1~)**

其中，**a~0~** 是唯一的“第一个”数据元素，又称为表头元素;**a~n−1~**是唯一的“最后一个”数据元素，又称为表尾元素。

线性表按照存储结构，可以分为顺序表和链表两种类型。本章课程只介绍顺序表，链表会在后面的一章里单独介绍。

其中，顺序表是在计算机内存中以数组形式保存的线性表，是指用一组地址连续的存储单元依次存储数据元素的线性结构。

## 6.顺序表

顺序表是线性表的一种顺序存储形式。换句话说，线性表是逻辑结构，表示元素之间一对一的相邻关系；而顺序表是存储结构，是指用一组地址连续的存储单元，依次存储线性表中的数据元素，从而使得逻辑上相邻的两个元素在物理位置上也相邻。

设顺序表的第一个元素 **a~0~**的存储地址为 **Loc(a~0~)**，每个元素占 d 个存储空间，则第 i 个元素的地址为:

**Loc(a~i-1~)=Loc(a~0~)+(i-1)*d**

顺序表在程序中通常用一维数组实现，一维数组可以是静态分配的，也可以是动态分配的。

在静态分配时，由于数组的大小和空间是固定的，一旦空间占满，就无法再新增数据，否则会导致数据溢出。

而在动态分配时，存储数组的空间在程序执行过程中会动态调整大小，当空间占满时，可以另行开辟更大的存储空间来储存数据。

顺序表最主要的特点是可以进行 **随机访问**，即可以通过表头元素的地址和元素的编号（下标），在 **O(1)**的时间复杂度内找到指定的元素。

顺序表的不足之处是插入和删除操作需要移动大量的元素，从而保持逻辑上和物理上的连续性。

## 顺序表

结构定义：

１．size

2.length

3.data_type = xxx

```c

```



## 堆排序　

1.将堆顶元素与堆尾元素交换

2.将此操作看做是堆顶元素弹出操作

3.按照头步弹出以后策略调整堆

## 线性建堆法

## 稳定排序（插入（n^2^）、冒泡(n^2^)、归并(logn)）

插入排序

口诀：１．将数组分成【已排序区】和待排序区

２．将已排序区后面一个元素，向前插入到代排序区

３．直到待排序去没有元素位置

```c
insert_sort(int *data, int length) {
	for (int i = 0; i < length - 2; i++) {
		for (int j = i; j > 0; j--) {
			if (data[j] > data[j - 1]) {
				swap(data[j], data[j - 1]);
            }
        }
    }
}
```



冒泡排序：

口诀：

１．将数组分成已排序区和待排序区

２．从头到尾草庙待排序区，若前面元素比后面元素大则交换

３．每一轮都会将待排序区中最大的放到已排序区的开头

４．直到待排序区没有元素为止。

```c
maopao_sort(int *data, int length) {
    for (int i = 0; i < length - 1; i++) {
        for (int j = 0; j < length - i - 1; j++) {
            if (data[j] > data[j + 1]) {
			swap(data[j + 1], data[j]);
            }
        }
    }
}
```



### 逆序数，冒泡排序每次交换减少一个逆序数对

归并排序：

１．分治

２．

## 不稳定排序



## 二分查找两类常见思维模型

















