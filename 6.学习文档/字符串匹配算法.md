# 字符串匹配算法

## 暴力匹配算法（ＢＦ算法）

１．母串Ｓ的第一个字符和模式串Ｔ的第一个字符进行比较

２．如果相等，则继续比较下一个字符是否相等

３．如果不相等，则选择母串ＳＤＥ第二个字符和模式串Ｔ第一个字符进行比较

４．重复步骤２和３，纸质母串Ｓ中匹配到模式串Ｔ或者枚举到母串末尾

ＢＦ算法嵌套了两重循环所以时间复杂度为Ｏ（n * m）.

优化，当对串匹配的信息越多时失败时，可以根据串特征，进行跳格优化。

## ＫＭＰ算法

![1546153966844](/tmp/1546153966844.png)

如果在ｎ位匹配失败，如果前面有

母串：Ｓａ＝　Ｓｂ

子串：Ｔａ　＝　Ｔｂ

且ｋ｛Ｓａ＋ x｝ +Ｌ　＝　ｎ　－　１

则可直接将子串的第ｋ－Ｔａ位后开始匹配

![1546155466642](/tmp/1546155466642.png)　	

* 在ＫＭＰ中如果模式串在i点出失配，则在模式串的T~0~^i-1^部分中其后缀是一段长度为最大公共子串的一段字符串，后缀末尾一定要在i - 1处结束，其前缀是一段长度为最大公共子串的一段字符串，前缀一定从模式串０位起始。
* ｎｅｘｔ数组记录的是从０到i  -1这一段字符串中的最长公共子串长度
* 因为存在第一行的性质所以既然在i左部存在一段长度为next[i - 1]所记录长度的最长公共子串（不包括从0到i - 1这一段全长，如果包含就会造成最长子串唯从0到i-1本串），那么一定存在一段从零开始的长为next[i - 1]长度的子串，那么我们在模式串与母串在i处不匹配时，应将母串与模式串T[next[i-1] + 1]比较。
* 同理在进行next数组初始化时，有第一行的性质所以既然在i左部存在一段长度为next[i - 1]所记录长度的最长公共子串（不包括从0到i - 1这一段全长，如果包含就会造成最长子串唯从0到i-1本串），那么一定存在一段从零开始的长为next[i - 1]长度的子串，那么我们在i点的模式串的next数组值应为：将模式串T[i]的值与模式串T[next[i-1] + 1]比较。如果两值相等则i点的next数组值应为next[i  - 1] + 1，如果两值不等，则将T[i]与T[next[next[n - 1]] + 1]的值比较，直至相等赋值或next值为-1。（不相等时相当于将整个模式串离散化，相当于模式串匹配时在next[i-1]位失配以此类推）。

![1546655239493](/tmp/1546655239493.png)

# 加餐：单调栈

* 单调栈负责维护最近最值

例：５，６，７，９，８，２，４

# 字典树

## AC自动机

* 通常建立失败指针是广度优先遍历
* 那么如何深度优先遍历建立失败指针呢？
* 

