# **面试问题系列**

## 关于局部变量

* 为何局部变量互不影响？
  * ans:因为在函数执行的过程是一个不断压栈的过程，因为每一个局部变量都在不同的空间，所以局部变量互不影响
* 为何栈区会自动回收？
  * ans:因为每一次函数执行的过程是一次出栈的过程，所以当函数执行完毕时，栈空

## 问题二

* 堆的底层数据结构(存储结构)是什么？
  * 块状链表
* 信息的表示影响了什么？
  * 影响了程序的效率，采取了什么数据结构影响算法的效率

## 关于存储区

* 常量存储区
* 静态存储区
* 局部的静态存储区会存储到栈区吗？
  * ans:不会，既然已经存储到静态存储区，就不会再存储到局部存储区，不会也不能存储到堆区，不能拥有两个地址
  * 所以没有存储到栈区的地址，在递归过程中会收到影响

## const

* const存储在栈区中，const使该变量不能被更改，用于声明不可改变变量，方便编译器排错。

## c++变量类型更改

* 隐式类型转换比较常见,在混合类型表达式中经常发生.比如在表达式中存在short和int,那么就过会发生整型提升.四种强制类型转换操作符：static_cast、dynamic_cast、const_cast、reinterpret_cast。

## **dynamic_cast**

1.dynamic_cast是在运行时检查的，用于在集成体系中进行安全的向下转换downcast(当然也可以向上转换，但没必要，因为可以用虚函数实现)

   即：基类指针/引用 -> 派生类指针/引用

   如果源和目标没有继承/被继承关系，编译器会报错！
2.dynamic_cast是4个转换中唯一的RTTI操作符，提供运行时类型检查。
3.dynamic_cast不是强制转换，而是带有某种”咨询“性质的，如果不能转换，返回NULL。这是强制转换做不到的。

4.源类中必须要有虚函数，保证多态，才能使用dynamic_cast<source>(expression)

# static_cast

用法：static_cast < type-id > ( expression )

该运算符把expression转换为type-id类型，在编译时使用类型信息执行转换，在转换执行必要的检测（指针越界，类型检查），其操作数相对是安全的。

但没有运行时类型检查来保证转换的安全性。

# reinterpret_cast

仅仅是复制n1的比特位到d_r, 没有进行必要的分析.interpret_cast是为了映射到一个完全不同类型\
的意思，这个关键词在我们需要把类型映射回原有类型时用到它。我们映射到的类型仅仅是为了故弄\
玄虚和其他目的，这是所有映射中最危险的。(这句话是C++编程思想中的原话

# const_cast

去除const常量属性，使其可以修改

and

volatile属性的转换  易变类型<->不同类型.

 

## 信息

* 程序要做某些事情，一定存储了某些必要的信息。