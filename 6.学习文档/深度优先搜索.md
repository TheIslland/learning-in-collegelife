[TOC]



## 深度优先搜索

### 简介

 深度优先搜索算法（DFS），是图算法的一种，其过程简要来说是对每一个可能的分支路径深入到不能再深入为止，而且每个节点只能访问一次。

 **连通图的深度优先遍历类似于树的先根遍历**



### DFS算法描述

1. 从图中v~0~出发，访问v~0~。
2. 找出v~0~的第一个未被访问的邻接点，访问该顶点。以该顶点为新顶点，重复此步骤，直至刚访问过的顶点没有未被访问的邻接点为止。
3. 返回前一个访问过的仍有未被访问邻接点的顶点，继续访问该顶点的下一个未被访问领接点。
4. 重复2,3步骤，直至所有顶点均被访问，搜索结束。

从这四点可以看出**深度优先搜索是一个递归过程**



### DFS空间复杂度

若有v个顶点、E条边：

- 用邻接表储存图，有O(V+E)
- 用邻接矩阵储存图，有O(V^2)



### 深度优先搜索的优化技巧

1. **优化搜索顺序**：在一些搜索问题中，搜索树的各个层次，各个分支之间的顺序是不固定的。不同的搜索顺序会产生不同的搜索树形态，其规模大小也相差甚远。
2. **排除等效冗余**：在搜索过程中，如果我们能够判定从搜索树的当前节点上沿着某几条不同分支到达的子树是等效的，那么只需要对其中的一条分支执行搜索。
3. **可行性剪枝（上下界剪枝）**：该方法判断继续搜索能否得出答案，如果不能直接回溯。        在搜索过程中，即使对当前状态进行检查，如果发现分支已经无法到达递归边界，就执行回溯。
4. **最优性剪枝**：最优性剪枝，是一种重要的搜索剪枝策略。它记录当前得到的最优值，如果当前结点已经无法产生比当前最优解更优的解时，可以提前回溯。
5. **记忆化**：可以记录每个状态的搜索结果，再重复遍历一个状态时直接检索并返回。这好比我们对图进行深度优先遍历时，标记一个节点是否已经被访问过。



### DFS核心代码

储存图的方式：

- 邻接表
- 邻接矩阵



实现遍历过程的方式：

- 通过栈维护
- 递归



**邻接矩阵储存图，通过递归遍历**

```c++
struct G {
    int arr[MAX_N][MAX_M];
    int num;
} G;

int vis[MAX_N] = {0};

void DFS(int v) {
	vis[v] = 1; // 访问过
	for (int i = 0; i < G.num; i++) {
		if (G.arr[v][i] && vis[i] == 0) { //递归调用
			DFS(i);
        }
    }
    return ;
}

```



**邻接矩阵储存图，通过非递归遍历**

```c++
struct G {
    int arr[MAX_N][MAX_M];
    int num;
} G;

int vis[MAX_N] = {0};

void DFS(int v){
    stack<int> s;
    s.push(v);
    vis[v] = 1; // 访问过
    
    while (!s.empty()) {
        int i = s.top(), j;
        for (j = i; j < G,num; j++) {
        	if(G.arr[i][j] && G.vis[j] == 0) { // 找到i的邻接点 
            	G.vis[j] = 1;
            	s.push(j); // 继续找j的邻接点
            	break; 
        	}
        }
        if(j == G.num){ // 没找到i的邻接点 
            s.pop();
        }
    }
    return ;
}
```



### 例题 HDU1010

http://acm.hdu.edu.cn/search.php?action=listproblem





## 记忆化搜索

因为搜索不能够很好地处理重叠子问题，动态规划虽然比较好地处理了重叠子问题，但是在有些拓扑关系比较复杂的题目面前，又显得无奈。记忆化搜索便将两种方法结合到一起，能更好的去处理问题。

**记忆化搜索 = 搜索的形式 + 动态规划的思想**



### 动态规划与记忆化搜索

- 动态规划就是一个最优化问题，先将问题分解为子问题，并且对于这些分解的子问题自身就是最优的才能在这个基础上得出我们要解决的问题的最优方案。动态规划不同于贪心算法，因为贪心算法是从局部最优来解决问题，而动态规划是全局最优的。
- 动态规划的一种变形就是记忆化搜索，就是根据动归方程写出递归式，然后在函数的开头直接返回以前计算过的结果，当然这样做也需要一个存储结构记下前面计算过的结果，所以又称为记忆化搜索。 
- 用一个数组或者其他的存储结构存储得到的子问题的解。这样就可以省很多时间，也就是典型的空间换时间 

### 记忆化搜索递归式动态规划

**记忆化搜索的思想** 

在搜索过程中，会有很多重复计算,如果我们能记录一些状态的答案，就可以减少重复搜索量。 

**记忆化搜索的适用范围** 

根据记忆化搜索的思想，它是解决重复计算，而不是重复生成，也就是说，这些搜索必须是在搜索扩展路径的过程中分步计算的题目，也就是“搜索答案与路径相关”的题目，而不能是搜索一个路径之后才能进行计算的题目，必须要分步计算，并且搜索过程中，一个搜索结果必须可以建立在同类型问题的结果上，也就是类似于动态规划解决的问题。 
其问题表达，不是单纯生成一个走步方案，而是生成一个走步方案的代价等，而且每走一步，在搜索树/图中生成一个新状态，都可以精确计算出到此为止的费用，也就是，可以分步计算，这样才可以套用已经得到的答案 。

**记忆化搜索的核心实现** 

1. 首先，要通过一个表记录已经存储下的搜索结果，一般用哈希表实现 
2. 状态表示，由于是要用哈希表实现，所以状态最好可以用数字表示，常用的方法是把一个状态连写成一个p进制数字，然后把这个数字对应的十进制数字作为状态 
3. 在每一状态搜索的开始，高效的使用哈希表搜索这个状态是否出现过，如果已经做过，直接调用答案，回溯
4. 如果没有，则按正常方法搜索 



**记忆化搜索是类似于动态规划的，不同的是，它是倒做的“递归式动态规划”**



### 斐波那契数列（记忆化版）

```c++
int f[MAX_N] = {0};

int func(int n) {
	if (f[n] != 0) return f[n];
	if (n <= 2) return (f[n] = 1);
	else return (f[n] = func(n - 2) + func(n - 1));
}
```



### 例题 矩形滑雪场

https://nanti.jisuanke.com/t/203





## 剪枝

### 简介

在搜索算法中优化中，剪枝，就是通过某种判断，避免一些不必要的遍历过程，形象的说，就是剪去了搜索树中的某些“枝条”，故称剪枝。应用剪枝优化的核心问题是设计剪枝判断方法，即确定哪些枝条应当舍弃，哪些枝条应当保留的方法。



### 剪枝优化三原则

搜索算法，绝大部分需要用到剪枝。然而，不是所有的枝条都可以剪掉，这就需要通过设计出合理的判断方法，以决定某一分支的取舍。在设计判断方法的时候,需要遵循一定的原则。

#### 正确性

枝条不是爱剪就能剪的。如果随便剪枝，把带有最优解的那一分支也剪掉了的话，剪枝也就失去了意义。所以，剪枝的前提是一定要保证不丢失正确的结果。

#### 准确性

在保证了正确性的基础上，我们应该根据具体问题具体分析，采用合适的判断手段，使不包含最优解的枝条尽可能多的被剪去，以达到程序“最优化”的目的。可以说，剪枝的准确性，是衡量一个优化算法好坏的标准。

#### 高效性

设计优化程序的根本目的，是要减少搜索的次数，使程序运行的时间减少。但为了使搜索次数尽可能的减少，我们又必须花工夫设计出一个准确性较高的优化算法，而当算法的准确性升高，其判断的次数必定增多，从而又导致耗时的增多，这便引出了矛盾。因此，如何在优化与效率之间寻找一个平衡点，使得程序的时间复杂度尽可能降低,同样是非常重要的。倘若一个剪枝的判断效果非常好，但是它却需要耗费大量的时间来判断、比较，结果整个程序运行起来也跟没有优化过的没什么区别，这样就太得不偿失了。



### 分类

#### 可行性剪枝

该方法判断继续搜索能否得出答案，如果不能直接回溯。

#### 最优性剪枝

最优性剪枝，又称为上下界剪枝，是一种重要的搜索剪枝策略。它记录当前得到的最优值，如果当前结点已经无法产生比当前最优解更优的解时，可以提前回溯。



### 剪枝策略的寻找的方法

- 微观方法：从问题本身出发，发现剪枝条件
- 宏观方法：从整体出发，发现剪枝条件。
- 注意提高效率，这是关键，最重要的。

总之，剪枝策略，属于算法优化范畴；通常应用在DFS 和 BFS 搜索算法中；剪枝策略就是寻找过滤条件，提前减少不必要的搜索路径。



### 例题 P1433 吃奶酪



## 练习题

### 练习题 HDU1331

http://acm.hdu.edu.cn/showproblem.php?pid=1331

### 习题走迷宫

给一个 n 行 m 列的 22 维的迷宫，'S'表示迷宫额起点，'T'表示迷宫的终点，'#'表示不能通过的点，'.' 表示可以通过的点。你需要从'S'出发走到'T'，每次只能上下左右走动，并且只能进入能通过的点，每个点只能通过一次。现在要求你求出有多少种通过迷宫的的方案。

输入格式
第一行输入 $n, m (1 \le n,m \le 10)(1≤n,m≤10)$ 表示迷宫大小。

接下来输入 n 行字符串表示迷宫。

输出格式
输入通过迷宫的方法数。

样例输入1

```c
2 3
S.#
..T
```

样例输出1

```c
2
```

样例输入2

```c
3 3
S..
.#.
..T
```

样例输出2

```c
2
```

* 题目分析:

  由题意可知我们可以通过深搜和方向数组，向四个方向遍历，走不通（到达边界）就return,通就一直走，直到终点方案数加一

* 代码：

  ```c++
  #include <iostream>
   
  using namespace std;
  
  //方向数组表示上下左右四种状态
  int xx[4] = {1, 0, -1, 0};
  int yy[4] = {0, 1, 0, -1};
  
  char node[20][20] = {0};
  
  int ans = 0, n, m;
  
  void dfs(int x, int y) {
      if (x < 0 || y < 0 || x >= n || y >= m) return ; //如果到达边界条件返回
      if (node[x][y] == '#' || node[x][y] == '1') return ; //如果无法走通返回
      if (node[x][y] == 'T') { //到达终点计数器加一
          ans++;
          return ;
      }
      node[x][y] = '1'; //走过当前点标记
      for (int i = 0; i < 4; i++) { //深搜遍历四个方向
          int tx = x + xx[i];
          int ty = y + yy[i];
          dfs(tx,ty);
      }
      node[x][y] = '.'; //还原标记节点
      return ;
  }
  
  int main() {
      int a, b;
      cin >> n >> m;
      char tmep;
      for (int i = 0; i < n; i++) {
          for (int j = 0; j < m; j++) {
              cin >> node[i][j];
              if (node[i][j] == 'S') {
                  a = i, b = j;
              }
          }
      }
      dfs(a, b);
      cout << ans << endl;
      return 0;
  }
  ```

### 练习题：踏青

蒜头君和他的朋友周末相约去召唤师峡谷踏青。他们发现召唤师峡谷的地图是由一块一块格子组成的，有的格子上是草丛，有的是空地。草丛通过上下左右 44 个方向扩展其他草丛形成一片草地，任何一片草地中的格子都是草丛，并且所有格子之间都能通过上下左右连通。如果用'G'代表草丛，'.'代表空地，下面的峡谷中有 22 片草地。

1
GG..
2
..GG
处在同一个草地的 22 个人可以相互看到，空地看不到草地里面的人。他们发现有一个朋友不见了，现在需要分头去找，每个人负责一片草地，蒜头君想知道他们至少需要多少人。

输入格式
第一行输入 $n, m (1 \le n,m \le 100)(1≤n,m≤100)$ 表示峡谷大小

接下来输入 nn 行字符串表示峡谷的地形

输入格式
输出至少需要多少人

样例输入

```c
5 6
.#....
..#...
..#..#
...##.
.#....
```

样例输出

```c
5
```

**题意分析:**

* 找到草丛节点开始向四周深搜，直到无法搜索，搜索过程中已搜索点标记，搜索ｎ次则ｎ块草丛

* 代码实现：

  ```c++
  #include <iostream>
  
  using namespace std;
  
  int n, m;
  char node[150][150] = {0};
  int xx[4] = {1, 0, -1, 0};
  int yy[4] = {0, 1, 0, -1};
  
  void dfs(int x, int y) {
      if (x < 0 || x >= n || y < 0 || y >= m) return ;
      if (node[x][y] == '.') return ;
      node[x][y] = '.';
      for (int i = 0; i < 4; i++) {
          int tx = x + xx[i];
          int ty = y + yy[i];
          dfs(tx, ty);
      }
      return ;
  }
  
  int main() {
      cin >> n >> m;
      int ans = 0;
      for (int i = 0; i < n; i++) {
          for (int j = 0; j < m; j++) {
              cin >> node[i][j]; 
          }
      }
      for (int i = 0; i < n; i++) {
          for (int j = 0; j < m; j++) {
              if (node[i][j] == '.') continue ;
              ans++;
              dfs(i, j);
          }
      }
      cout << ans << endl;
      return 0;
  }
  ```

### 练习题：买书

蒜头君去书店买书，他有 mm 元钱，书店里面有 nn 本书，每本书的价格为 p_ipi 元。蒜头君很爱学习，想把身上钱都用来买书，并且刚好买 kk 本书。请帮蒜头君计算他是否能刚好用 mm 元买 kk 本书。

输入格式
第一行输入 33 个整数 $m(1 \le m \le 100000000)m(1≤m≤100000000)，n(1 \le n \le 30)n(1≤n≤30)，k(1 \le k \le min(8, n))k(1≤k≤min(8,n))$

接下来一行输入 nn 个整数，表示每本书的价格 $p_i(1 \le p_i \le 100000000)p_i(1≤p_i≤100000000)$。

输出格式
如果蒜头君能 刚好 用 mm 元买 kk 本书，输入一行"Yes", 否则输出"No"。

样例输入1

```c
10 4 4
1 2 3 4
```

样例输出1

```c
Yes
```

样例输入2

```c
10 4 3
1 2 3 4
```

样例输出2

```c
No
```

**题目分析：**

* 由题意可知 dfs深度搜索  当总价格和总数量与初始化相等时 可以购买  否则不能购买  略微剪枝;

* 代码实现：

  ```c++
  #include <iostream>
  
  using namespace std;
  
  long long int n, m, k;
  
  long long int pi[100];
  
  bool dfs(long long int i, long long int sum, long long int num) {
      if (i == n) {
          return ((sum == m) && (num == k));
      }
      //最优解剪枝
      if (num > k || sum > m) return false;
      if (dfs(i + 1, sum, num)) return true;
      if (dfs(i + 1, sum + pi[i], num + 1)) return true;
      return false;
  }
  
  int main() {
      cin >> m >> n >> k;
      for (long long int i = 0; i < n; i++) cin >> pi[i];
      if (dfs(0, 0, 0)) {
          cout << "Yes" << endl;
      } else {
          cout << "No" << endl;
      }
      return 0;
  }
  ```

### 练习题：方程的解

蒜头君在求解一个 nn 元的高次方程：

$\displaystyle k_1x_1^{p_1}+k_2x_2^{p_2}+\ldots+k_nx_n^{p_n}=0k1x1p1+k2x2p2+…+knxnpn=0$

其中：x_1,x_2,\ldots,x_nx1​,x2​,…,xn​ 是未知数，k_1,k_2,\ldots,k_nk1​,k2​,…,kn​ 是系数，p_1,p_2,\ldots,p_np1​,p2​,…,pn​ 是指数。方程中所有数都一定是整数。

假设未知数 $1\leq x_i\leq M,i=1 \ldots n1≤xi≤M,i=1…n$。你能帮蒜头君算出这个方程的整数解个数吗？

输入格式
第一行输入一个整数 $n(1 \leq n \leq 4)n(1≤n≤4)$。

第二行输入一个整数 $M(1 \leq M \leq 150)M(1≤M≤150)$。

第 33 行到第 n+2n+2 行，每行输入两个整数，分别表示 $k_i(|k_i| \leq 20)ki(∣ki∣≤20) 和 p_i(1 \leq p_i \leq 4)pi(1≤pi≤4)$。两个整数之间用一个空格隔开。

输出格式
输出一行，输出一个整数，表示方程的整数解的个数。

样例输入

```c
3
100
1 2
-1 2
1 2
```

样例输出

```c
104
```

**题目分析：**

* 逐次尝试可能解 当存在解时  计数器+1     注意打表  pow多次运算会很慢

* 代码实现：

  ```c++
  #include <iostream>
  using namespace std;
  
  int n, m, ans = 0, sum = 0;
  
  int k[155], p[155], temp[160][5], value[15];
  
  void init() {
      memset(temp, 1, sizeof(temp));
  	for (int i = 1; i <= 150; i++) {
  		for (int j = 1; j <= 4; j++) {
  			temp[i][j] = i * temp[i][j - 1];
          }
      }
  }
  
  void dfs(int i) {
      if (i == n + 1) {
  		sum = 0;
          for (int i = 1; i <= n; i++)
          sum += k[i] * temp[value[i]][p[i]];
          if (sum == 0) ans++;
          return ;
      }
      for (int j = 1; j <= m; j++) {
      	value[i] = j;
          dfs(i + 1);
      }
      return ;
  }
  
  int main() {
      init();
      cin >> n >> m;
      for (int i = 1; i <= n; i++) {
          cin >> k[i] >> p[i];
      }
      dfs(1);
      cout << ans << endl;
      return 0;
  }
  ```

### 练习题：等边三角形

蒜头君手上有一些小木棍，它们长短不一，蒜头君想用这些木棍拼出一个等边三角形，并且每根木棍都要用到。 例如，蒜头君手上有长度为 1，2，3，3 的4根木棍，他可以让长度为1，2的木棍组成一条边，另外 2 跟分别组成 2条边，拼成一个边长为 3 的等边三角形。蒜头君希望你提前告诉他能不能拼出来，免得白费功夫。

输入格式
首先输入一个整数 $n(3 \le n \le 20)n(3≤n≤20)$，表示木棍数量，接下来输入 n 根木棍的长度 $p_i(1 \le p_i \le 10000)pi(1≤pi≤10000)$。

输出格式
如果蒜头君能拼出等边三角形，输出"yes"，否则输出"no"。

样例输入1

```c样例输出1
5
1 2 3 4 5
```

样例输出１

```c
yes
```

样例输入2

```c
4
1 1 1 1
```

样例输出2

```c
no
```

**题目解析:**

* 这道题目又是一道选择的题目，我们有三种选择的方法。

  1：我们把这根木棍放到第一条边上。

  2：我们把这根木棍放到第二条边上。

  3：我们把这根木棍放到第三条边上。

  对应三个`dfs`。与此同时处理好递归出口的问题就好了。

  接下来我要说说这道题目的不同。我们对于这道题目我们可以进行一定的剪枝。

  1：当平均值不是整数的时候我们就可以直接判定是无法拼成等边三角形的。

  2：当其中的一个木棍长度大于平均值，也是无法拼成等边三角形的。

  3：最优性剪枝，当你搜索到答案的时候，就结束所有的递归。

  这个时候是不是发现其实优化也不是那么难？其实更多的优化都是我们自己可以想出来的，一个看似简单的优化，会给你的代码提高极大的运行效率。

* 代码：

  ```c++
  #include <iostream>
  
  using namespace std;
  
  int n, flag = 0, num, sum = 0;
  double len = 0;
  int a[40];
  int temp[4];
  
  void dfs(int i, int num) {
      temp[num] += a[i];
      //剪枝2最优性剪枝
      if (flag) return ;
      //剪枝３
      if (temp[0] > len || temp[1] > len || temp[2] > len) {
          temp[num] -= a[i];
          return ;
      }
      if (temp[0] == len && temp[1] == len && temp[2] == len) {
          flag = 1;
          return ;
      }
      //三路枚举
      if (i + 1 < n) {
          if (!flag) dfs(i + 1, 0);
          if (!flag) dfs(i + 1, 1);
          if (!flag) dfs(i + 1, 2);
      }
      temp[num] -= a[i];
      return ;
  }
  
  int main() {
      cin >> n;
      for (int i = 0; i < n; i++) {
          cin >> a[i];
          len += a[i];
      }
      len /= 3;
      //剪支１
      if (len > (int)len) {
          cout << "no" << endl;
      } else {
          dfs(0, 0);
          if (flag) cout << "yes" << endl;
          else cout << "no" << endl;
      }
      return 0;
  }
  ```

### 洛谷Ｐ１２１９Ｎ皇后

检查一个如下的6 x 6的跳棋棋盘，有六个棋子被放置在棋盘上，使得每行、每列有且只有一个，每条对角线(包括两条主对角线的所有平行线)上至多有一个棋子。

![img](https://cdn.luogu.org/upload/pic/60.png)

上面的布局可以用序列2 4 6 1 3 5来描述，第i个数字表示在第i行的相应位置有一个棋子，如下：

行号 1 2 3 4 5 6

列号 2 4 6 1 3 5

这只是跳棋放置的一个解。请编一个程序找出所有跳棋放置的解。并把它们以上面的序列方法输出。解按字典顺序排列。请输出前3个解。最后一行是解的总个数。

输入输出格式

输入格式：

一个数字N (6 <= N <= 13) 表示棋盘是N x N大小的。

输出格式： 

前三行为前三个解，每个解的两个数字之间用一个空格隔开。第四行只有一个数字，表示解的总数。

输入输出样例

输入样例#1： 

```
6
```

输出样例#1： 

```
2 4 6 1 3 5
3 6 2 5 1 4
4 1 5 2 6 3
4
```

**提议解析:**

* n皇后问题要求我们在保证八个方向上皇后独立存在，我们在每一层中确定皇后的位置，故行数不用存储，而列数存储，因为要确定左右斜向对角线故增加两个数组存储对角先是否被占用，由题意可知单一方向上对角线个数为2 * n - 1个，故得到行与列值到对角线映射关系，深搜求解。

* 代码实现：

  ```c++
  #include <iostream>
  using namespace std;
  
  int n;  // 棋盘大小
  int ans = 0;  // 解的个数
  int a[30] = {0};  // 列占用情况，若第 i 列被占用，则 a[i] = true，否则为 false
  int x1[30] = {0};  // 左下-右上 对角线的占用情况
  int y1[30] = {0};  // 左上-右下 对角线的占用情况
  int num[30];
  void print() {
      if (ans <= 2) {
          for (int i = 0; i < n; i++) {
              cout << num[i] + 1 << " ";
          }
              cout << endl;
      }
      ans++;
  }
  void dfs(int deep) {  // deep 表示当前搜索到第几行
      if (deep >= n) {  // 搜索完最后一行，说明找到了一组合法解
          print();
          return;  // 回溯
      }
      for (int i = 0; i < n; i++) {  // 枚举当前行的皇后放置到第 i 列
          if (x1[i + deep] == 0 && y1[i - deep + n] == 0 && a[i] == 0) {  // 判断该皇后是否与已放置的皇后发生冲突
              // 放置皇后 (deep, i)，一共需要修改三个标记数组
              x1[deep + i] = 1;
              y1[i - deep + n] = 1;
              a[i] = 1;
              num[deep] = i;
              dfs(deep + 1);  // 当前行枚举完毕，搜索下一行
              // 恢复放置皇后 (deep, i) 前的状态
              a[i] = 0;
              x1[deep + i] = 0;
              y1[i - deep + n] = 0;
          }
      }
  }
  int main() {
      cin >> n;
      dfs(0);
      cout << ans;
      return 0;
  }
  ```

  