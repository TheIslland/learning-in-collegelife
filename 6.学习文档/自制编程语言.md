# 自制编程语言

## 一、环境需求

* JAVA 1.8.0
* Antlr 3.4
* 支持C++11标准的编译环境
* 系统无特殊要求

## 二、前导知识

* EBNF文法（扩展巴科斯范式）
* C/C++语言基础
* 搜索算法基础
* 面向对象程序设计基础

## 三、环境安装

(环境[变量](https://baike.baidu.com/item/%E5%8F%98%E9%87%8F)相当于给系统或用户[应用程序](https://baike.baidu.com/item/%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F)设置的一些参数，具体起什么作用这当然和具体的环境变量相关。比如path，是告诉系统，当要求系统运行一个程序而没有告诉它程序所在的完整路径时，系统除了在[当前目录](https://baike.baidu.com/item/%E5%BD%93%E5%89%8D%E7%9B%AE%E5%BD%95)下面寻找此程序外，还应到哪些目录下去寻找；再如tc或vc++中，set include=path1;path2; 是告诉[编译程序](https://baike.baidu.com/item/%E7%BC%96%E8%AF%91%E7%A8%8B%E5%BA%8F)到哪里去找.h类型的文件；当然不仅仅是指定什么路径，还有其它的作用的，如set dircmd=/4 设置一个环境变量的作用是在使用dir[命令](https://baike.baidu.com/item/%E5%91%BD%E4%BB%A4)时会把/4作为缺省的参数添加到你的dir命令之后，就像你的每个命令都加了/4参数，它实际上是给命令[解释程序](https://baike.baidu.com/item/%E8%A7%A3%E9%87%8A%E7%A8%8B%E5%BA%8F)command设置的一个环境变量，并且是给dir这个[内部命令](https://baike.baidu.com/item/%E5%86%85%E9%83%A8%E5%91%BD%E4%BB%A4)设置的。)

* **1、下载Antlr**

  ```shell
  #下载Antlr 3.4 C 语言库以及文法转换过程中需要的jar包
  weget http://www.antlr3.org/download/C/libantlr3c-3.4.tar.gz
  weget http://www/antlr3.org/donload/antlr-3.4-complete.jar
  #解压文件，tar.gz
  ```

  * 作用：将我们的文法文件转换成程序代码

  * 功能：将符合我们文法描述的一段文本，转换成一棵抽象文法树，是一种c或c++的内部数据结构。

  * 附录：1.任意叉树都可以表示成左孩子右兄弟的二叉树

    ​		Antlr根据编写的文法文件控制生成抽象文法树

## 四、操作步骤

* 1.配置JAVA环境

  * java jdk下载网站http://www.oracle.com/technetwork/java/javase/downloads/jdk8-downloads-2133151.html

  * ![选择如下版本](/home/mason/图片/java下载.png)

  * 选择Linux x86版本下载

  * 使用tar -axvf 解压缩后在客户端更改.profile文件添加如下内容：

    ```shell
    JAVA_HOME=/usr/java/jdk1.8.0_151        
    JRE_HOME=/usr/java/jdk1.8.0_151/jre     
    CLASS_PATH=.:$JAVA_HOME/lib/dt.jar:$JAVA_HOME/lib/tools.jar:$JRE_HOME/lib
    PATH=$PATH:$JAVA_HOME/bin:$JRE_HOME/bin
    export JAVA_HOME JRE_HOME CLASS_PATH PATH
    ```

    

  * 使用`source /etc/profile`让其生效

* 安装及配置Antlr3.4

  * 一、编译安装antlr c library

    ```shell
    wget http://www.antlr3.org/download/C/libantlr3c-3.4.tar.gz
    tar -xzvf ./libantlr3c-3.4.tar.gz
    ./configure --enable-64bit
    make
    sudo make install
    ```

    

  * 下载antlr 3.4 jar包

    尽管我们安装了c library，但是从.g文件，到各种.h .c文件的过程，还是要依赖antlr java的。

    特别注意：必须要用3.4的jar包

    `wget http://www.antlr3.org/download/antlr-3.4-complete.jar`

  * 建立第三方文件目录

    `mkdir thirdpart`方便管理和使用这里取名为thirdpart

    进入新建好的文件目录 `cd thirdpart` ，再在里面新建两个文件目录 `mkdir include` （这里面主要是放头文件的）和 `mkdir libs` （这里面是放一个叫做 libantlr3c.a的静态链接库）。然后在thirdpart目录下输入下面的命令 
    `cp ../include/* ./include` 这是把头文件拷贝到前面建好的头文件夹中。 

    接着输入 `cp ../.libs/libantlr3c.a ./libs` 这是拷贝静态链接库到新建的libs中。 

  * 编译愈发文件（.g）

    ```shell
    grammar ExprCppTree;
    
    options {
        language = C;
        output = AST;
        ASTLabelType=pANTLR3_BASE_TREE;
    }
    
    @header {
        #include <assert.h>
    }
    
    // The suffix '^' means make it a root.
    // The suffix '!' means ignore it.
    
    expr: multExpr ((PLUS^ | MINUS^) multExpr)*
        ;
    
    PLUS: '+';
    MINUS: '-';
    
    multExpr
        : atom (TIMES^ atom)*
        ;
    
    TIMES: '*';
    
    atom: INT
        | ID
        | '('! expr ')'!
        ;
    
    stmt: expr NEWLINE -> expr  // tree rewrite syntax
        | ID ASSIGN expr NEWLINE -> ^(ASSIGN ID expr) // tree notation
        | NEWLINE ->   // ignore
        ;
    
    ASSIGN: '=';
    
    prog
        : (stmt {pANTLR3_STRING s = $stmt.tree->toStringTree($stmt.tree);
                 assert(s->chars);
                 printf(" tree \%s\n", s->chars);
                }
            )+
        ;
    
    ID: ('a'..'z'|'A'..'Z')+ ;
    INT: '~'? '0'..'9'+ ;
    NEWLINE: '\r'? '\n' ;
    WS : (' '|'\t')+ {$channel = HIDDEN;};
    ```

    

  * 生成中间文件（抽象语法书）

    ```shell
    java -jar ../antlr-3.4-complete.jar ./ExprCppTree.g
    # 看一下文件，应该有这些
    ExprCppTree.g  ExprCppTreeLexer.c  ExprCppTreeLexer.h  ExprCppTreeParser.c  ExprCppTreeParser.h  ExprCppTree.tokens
    ```

    

  * 编写驱动文件

    ```c++
    #include "ExprCppTreeLexer.h"
    #include "ExprCppTreeParser.h"
    #include <cassert>
    #include <map>
    #include <string>
    #include <iostream>
    
    using std::map;
    using std::string;
    using std::cout;
    
    class ExprTreeEvaluator {
        map<string,int> memory;
    public:
        int run(pANTLR3_BASE_TREE);
    };
    
    pANTLR3_BASE_TREE getChild(pANTLR3_BASE_TREE, unsigned);
    const char* getText(pANTLR3_BASE_TREE tree);
    
    int main(int argc, char* argv[])
    {
      pANTLR3_INPUT_STREAM input;
      pExprCppTreeLexer lex;
      pANTLR3_COMMON_TOKEN_STREAM tokens;
      pExprCppTreeParser parser;
    
      assert(argc > 1);
      input = antlr3FileStreamNew((pANTLR3_UINT8)argv[1],ANTLR3_ENC_8BIT);
      lex = ExprCppTreeLexerNew(input);
    
      tokens = antlr3CommonTokenStreamSourceNew(ANTLR3_SIZE_HINT,
                                                TOKENSOURCE(lex));
      parser = ExprCppTreeParserNew(tokens);
    
      ExprCppTreeParser_prog_return r = parser->prog(parser);
    
      pANTLR3_BASE_TREE tree = r.tree;
    
      ExprTreeEvaluator eval;
      int rr = eval.run(tree);
      cout << "Evaluator result: " << rr << '\n';
    
      parser->free(parser);
      tokens->free(tokens);
      lex->free(lex);
      input->close(input);
    
      return 0;
    }
    
    int ExprTreeEvaluator::run(pANTLR3_BASE_TREE tree)
    {
        pANTLR3_COMMON_TOKEN tok = tree->getToken(tree);
        if(tok) {
            switch(tok->type) {
            case INT: {
                const char* s = getText(tree);
                if(s[0] == '~') {
                    return -atoi(s+1);
                }
                else {
                    return atoi(s);
                }
            }
            case ID: {
                string var(getText(tree));
                return memory[var];
            }
            case PLUS:
                return run(getChild(tree,0)) + run(getChild(tree,1));
            case MINUS:
                return run(getChild(tree,0)) - run(getChild(tree,1));
            case TIMES:
                return run(getChild(tree,0)) * run(getChild(tree,1));
            case ASSIGN: {
                string var(getText(getChild(tree,0)));
                int val = run(getChild(tree,1));
                memory[var] = val;
                return val;
            }
            default:
                cout << "Unhandled token: #" << tok->type << '\n';
                return -1;
            }
        }
        else {
            int k = tree->getChildCount(tree);
            int r = 0;
            for(int i = 0; i < k; i++) {
                r = run(getChild(tree, i));
            }
            return r;
        }
    }
    
    pANTLR3_BASE_TREE getChild(pANTLR3_BASE_TREE tree, unsigned i)
    {
        assert(i < tree->getChildCount(tree));
        return (pANTLR3_BASE_TREE) tree->getChild(tree, i);
    }
    
    const char* getText(pANTLR3_BASE_TREE tree)
    {
        return (const char*) tree->getText(tree)->chars;
    }
    ```

    

  * 编译、测试

    ```shell
    # 此处，我直接链接的静态.a库
    g++ -g -Wall *.cpp *.c ../thirdpart/libs/libantlr3c.a -o test -I. -I ../thirdpart/include/
    ```

    也可以选择使用`makefile`

    ```makefile
    CXX := g++
    CFLAGS := -g #-wall
    OBJS = *.cpp *.c
    LIBA = ../thirdpart/libs/libantlr3c.a
    
    test: 
    	@$(CXX) $(CFLAGS) $(OBJS) $(LIBA) -o test -I. -I ../thirdpart/include/
    
    .PHONY: clean install
    clean:
    	@rm test
    
    install:
    	@cp ../libantlr3c-3.4/include/* ./include
    	@ cp ../libantlr3c-3.4/.libs/libantlr3c.a ./libs
    ```

    

    ```shell
    cat ./data
    1+2*(3+4)
    ./test data
     tree (+ 1 (* 2 (+ 3 4)))
    Evaluator result: 15
    ```

* 

## 五、什么是BNF范式,什么又是EBNF范式?

* 巴科斯范式及其扩展BNF & Augmented BNF    
* **什么是巴科斯范式？**    

　　巴科斯范式(BNF: Backus-Naur Form 的缩写)是由 John Backus 和 Peter Naur 首先引入的用来描述计算机语言语法的符号集。
　　现在，几乎每一位新编程语言书籍的作者都使用巴科斯范式来定义编程语言的语法规则.

* **巴科斯范式的内容**  

  * 在双引号中的字("word")代表着这些字符本身。而double_quote用来代表双引号。
  * 在双引号外的字（有可能有下划线）代表着语法部分。 
  * 尖括号( < > )内包含的为必选项。 
  * 方括号( [ ] )内包含的为可选项。 
  * 大括号( { } )内包含的为可重复0至无数次的项。 
  * 竖线( | )表示在其左右两边任选一项，相当于"OR"的意思。 
  * ::= 是“被定义为”的意思。 

* **巴科斯范式示例**  

  这是用BNF来定义的[Java语言](https://www.baidu.com/s?wd=Java%E8%AF%AD%E8%A8%80&tn=24004469_oem_dg&rsv_dl=gh_pl_sl_csd)中的For语句的实例：

  ```shell
  FOR_STATEMENT ::= 
        "for" "(" ( variable_declaration | 
    ( expression ";" ) | ";" ) 
        [ expression ] ";" 
        [ expression ] ";" 
        ")" statement
  ```

*  **扩展的巴科斯范式 Augmented BNF**  
    　　RFC2234 定义了扩展的巴科斯范式(ABNF)。近年来在Internet的定义中ABNF被广泛使用。ABNF做了更多的改进，比如说，在ABNF中，尖括号不再需要。 

  ```c
  "..." : 术语符号
    [...] : 选项:最多出现一次
    {...} : 重复项: 任意次数，包括 0 次
    (...) : 分组
      |   : 并列选项，只能选一个
  斜体字: 参数，在其它地方有解释
  ```

  

## 0、相关

* 切换目录命令`pushd` `popd`  `cd`
* `pushd`将当前路径压入栈中
* `popd`从栈顶取出路径
* java可移植的原因，因为每一个系统是都有一个已经编译完成的java虚拟机（jvm）
* java（jvm）虚拟机是由c编写的