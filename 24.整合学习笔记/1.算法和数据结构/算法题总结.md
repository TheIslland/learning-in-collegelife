# 算法题总结

## 目录

* **一、数组**
  * 数组操作
  * 二维数组
  * 子数组与连续数组
  * 排列组合
  * 排序
  * 二分查找
    * Leetcode35：[查找插入位置](#Leetcode35：查找插入位置)（`二分查找` `easy`）
    * 《剑指offer》面试题11：[旋转数组的最小数字](旋转数组的最小数字)（`二分查找`）
  * 其他查找
  * 场景模拟
* **二、字符串**
* **三、栈和队列**
* **四、链表**
* **五、树**
* **六、数学**
* **七、图**
* **八、设计模式**
* **九、海量数据**
* **十、C\C++基础**

## <a id='Leetcode35：查找插入位置'>Leetcode35：查找插入位置</a>

[OJ链接](https://leetcode.com/problems/search-insert-position/description/)

给定一个排序数组和一个目标值，在数组中找到目标值，并返回其索引。如果目标值不存在于数组中，返回它将会被按顺序插入的位置。

你可以假设数组中无重复元素。

示例 1:

```
输入: [1,3,5,6], 5
输出: 2
```

示例 2:

```
输入: [1,3,5,6], 2
输出: 1
```

示例 3:

```
输入: [1,3,5,6], 7
输出: 4
```

示例 4:

```
输入: [1,3,5,6], 0
输出: 0
```

### 解答:

* 解法一：使用二分查找，由题意可知当目标数字再数组中存在是二分查找会返回数组下标，反之当目标数字再数组中不存在时返回`l`左边界值即可知插入位置：

  * ```c
    int searchInsert(int* nums, int numsSize, int target){
        int l = 0, r = numsSize - 1;
        while (l <= r) {
            int mid = (l + r) >> 1;
            if (nums[mid] < target) l = mid + 1;
            else if (nums[mid] > target) r = mid - 1;
            else return mid;
        } 
        return l;
    };
    ```

  * ```c
    //由题意分析可知我们只要nums[i]<目标值就像右找，当nums[i]>=目标值则向左找
    int searchInsert(int* nums, int numsSize, int target) {
        int head = -1, tail = numsSize - 1, mid;
        while (head < tail) {
            mid = (head + tail + 1) >> 1;
            if (nums[mid] < target) head = mid;
            else tail = mid - 1;
        }
        return head + 1;
    }
    ```

* 解法二：遍历查找

  * ```c
    int searchInsert(int* nums, int numsSize, int target) {
        for (int i = 0; i < numsSize; i++) {
    		if(nums[i] >= target) return i;
        }
        return numsSize;
    }
    ```

## <a id='旋转数组的最小数字'>旋转数组的最小数字</a>

[OJ链接](https://www.nowcoder.com/practice/9f3231a991af4f55b95579b44b7a01ba?tpId=13&tqId=11159&tPage=1&rp=2&ru=%2Fta%2Fcoding-interviews&qru=%2Fta%2Fcoding-interviews%2Fquestion-ranking)

把一个数组最开始的若干个元素搬到数组的末尾，我们称之为数组的旋转。 输入一个非递减排序的数组的一个旋转，输出旋转数组的最小元素

例如数组`{3,4,5,1,2}`为`{1,2,3,4,5}`的一个旋转，该数组的最小值为`1`

NOTE：给出的所有元素都大于`0`，若数组大小为`0`，请返回`0`

* 解法一：二分法查找

  * ```c
    class Solution {
    public:
        int minNumberInRotateArray(vector<int> rotateArray) {
             int  l = 0, r = rotateArray.size() - 1;
                while (l < r) {
                    int mid = (l + r) >> 1;
                    if (rotateArray[l] < rotateArray[r]) return rotateArray[l];
                    else if (rotateArray[mid] > rotateArray[l]) l = mid + 1;
                    else if (rotateArray[mid] < rotateArray[r])r = mid;
                    else ++l;
                }
                return rotateArray[l];
        }
    };
    ```

    

  * 

* 解法二：先排序再输出

* 解法三：遍历

