# 算法题总结

## 目录

* **一、数组**
  * 数组操作
  * 二维数组
  * 子数组与连续数组
  * 排列组合
  * 排序
  * 二分查找
    * Leetcode35：[查找插入位置](#Leetcode35：查找插入位置)（`二分查找` `easy`）
    * 《剑指offer》面试题11：[旋转数组的最小数字](旋转数组的最小数字)（`二分查找`）
    * Leetcode33：[旋转数组中查找数字](Leetcode33：旋转数组中查找数字)（`二分查找` `medium`）
    * Leetcode81：[旋转数组中查找数字II](Leetcode81：旋转数组中查找数字II)（`二分查找` `medium`）
    * Leetcode162：[寻找峰值](Leetcode162：寻找峰值)（`二分查找` `medium`）
    * Leetcode4:[寻找两个有序数组的中位数](Leetcode4:寻找两个有序数组的中位数)  (`二分查找` `medium`)
  * 其他查找
  * 场景模拟
* **二、字符串**
* **三、栈和队列**
* **四、链表**
* **五、树**
* **六、数学**
* **七、图**
* **八、设计模式**
* **九、海量数据**
* **十、C\C++基础**
  * [const小点](const小点)
* **十一、其他**

## <a id='Leetcode33：旋转数组中查找数字'>Leetcode33：旋转数组中查找数字</a>

[OJ链接](https://leetcode.com/problems/search-in-rotated-sorted-array/description/)

假设按照升序排序的数组在预先未知的某个点上进行了旋转。

( 例如，数组 `[0,1,2,4,5,6,7]` 可能变为 `[4,5,6,7,0,1,2]` )。

搜索一个给定的目标值，如果数组中存在这个目标值，则返回它的索引，否则返回 `-1` 。

你可以假设数组中不存在重复的元素。

你的算法时间复杂度必须是 O(log n) 级别。

示例 1:

```
输入: nums = [4,5,6,7,0,1,2], target = 0
输出: 4
```

示例 2:

```
输入: nums = [4,5,6,7,0,1,2], target = 3
输出: -1
```

* 解法一

  * 首先，如果`nums[mid] == target`，那么找到目标元素，返回`mid`

  * `如果nums[l] < nums[r]`，说明`l~r`范围的元素有序，那么执行正常的二分查找

  * 否则，根据`mid`位置的值判断`mid`是在左半部分还是右半部分

    - 如果`nums[mid] ≥ nums[l]`，说明`mid`在左半部分
      - 当`target > nums[r] && target < nums[mid]`，那么`target`只可能出现在`mid`的左边，因此在`mid`左边继续查找
      - 否则，`target`只可能出现在`mid`的右边，因此在`mid`右边继续查找

    - 否则，`mid`在右半部分
      - 当`target > nums[mid] && target < nums[l]`，那么`target`只可能出现在`mid`的右边，因此在`mid`右边继续查找
      - 否则，`target`只可能出现在`mid`的左边，因此在`mid`左边继续查找

  * ```c
    class Solution {
    public:
        int search(vector<int>& nums, int target) {
            int l = 0, r = nums.size() - 1;
            while (l <= r) {
                int mid = (l + r) >> 1;
                if (nums[mid] == target) return mid;
                if (nums[l] < nums[r]) {
                    if (nums[mid] > target) {
                        r = mid - 1;
                    } else {
                        l = mid + 1;
                    }
                } else {
                    if (nums[l] > nums[mid]) {
                        if (target > nums[mid] && target < nums[l]) {
                            l = mid + 1;
                        } else {
                            r = mid - 1;
                        }
                    } else {
                        if (target < nums[mid] && target > nums[r]) {
                            r = mid - 1;
                        } else {
                            l = mid + 1;
                        }
                    }      
                }
            }
            return -1;
        }
    };
    ```

  * 

* 解法二

  ```c++
  class Solution {
  public:
      int search(vector<int>& nums, int target) {
          int lo = 0, hi = nums.size() - 1;
          while (lo < hi) {
              int mid = (lo + hi) / 2;
              if ((nums[0] > target) ^ (nums[0] > nums[mid]) ^ (target > nums[mid]))
                  lo = mid + 1;
              else
                  hi = mid;
          }
          return lo == hi && nums[lo] == target ? lo : -1;
      }
  };
  ```

  


## <a id='Leetcode81：旋转数组中查找数字II'>Leetcode81：旋转数组中查找数字II</a>

[OJ链接](https://leetcode.com/problems/search-in-rotated-sorted-array-ii/description/)

假设按照升序排序的数组在预先未知的某个点上进行了旋转。

( 例如，数组 `[0,0,1,2,2,5,6]` 可能变为 `[2,5,6,0,0,1,2]` )。

编写一个函数来判断给定的目标值是否存在于数组中。若存在返回 `true`，否则返回 `false`。

示例 1:

```
输入: nums = [2,5,6,0,0,1,2], target = 0
输出: true
```

示例 2:

```
输入: nums = [2,5,6,0,0,1,2], target = 3
输出: false
```

进阶:

- 这是 [旋转数组中查找数字](https://github.com/appleis/note/blob/master/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E7%AE%97%E6%B3%95%E9%A2%98%E6%80%BB%E7%BB%93.md#%E6%97%8B%E8%BD%AC%E6%95%B0%E7%BB%84%E4%B8%AD%E6%9F%A5%E6%89%BE%E6%95%B0%E5%AD%97) 的延伸题目，**本题中的 nums 可能包含重复元素**
- 这会影响到程序的时间复杂度吗？会有怎样的影响，为什么？

### 解答

相比于前一题，这一题可能包含重复

总的思路还是不变，不过要处理一种特殊情况，即`nums[l] == nums[r] && nums[l] == nums[mid]`时，此时无法确定`mid`在左半部分还是右半部分。因此，当出现这种情况时，在区间`[l,r]`中，执行顺序查找

* 解法一

  * ```c
    bool search(int* nums, int numsSize, int target){
        int l = 0, r = numsSize - 1, mid;
        while (l <= r) {
            mid = (l + r) >> 1;
            if (nums[mid] == target) return true;
            if (nums[l] < nums[r]) {
                if (nums[mid] > target)  r = mid - 1;
                else l = mid + 1;
            } else if (nums[l] == nums[mid] && nums[r] == nums[mid]) {
                l++;
            } else {
                if (nums[l] <= nums[mid]) {
                    if (nums[mid] > target && target > nums[r]) r = mid - 1;
                    else l = mid + 1;
                } else {
                    if (nums[mid] < target && target < nums[l]) l = mid + 1;
                    else r = mid - 1;
                }
            }
        }
        return false;
    }
    ```

* 解法二

  * ```c
    bool search(int* a, int n, int target){
      // 找到最小的元素
      int pos = -1;
      for (int i = 0; i < n-1; i++) {
        if (a[i] > a[i+1]) {
          pos = i + 1;
        }
      }
    
      int left = 0;
      int right = n - 1;
    
      // 修剪 left 或者 right
      if (pos != -1) {
        if (target > a[pos-1] || target < a[pos]) {
          return false;
        }
    
        if (target > a[right]) {
          right = pos - 1;
        } else if (target < a[right]) {
          left = pos;
        } else {
          return true;
        }
      }
    
      int mid;
      while (left <= right) {
        mid = (left + right) / 2;
        if (a[mid] == target) {
          return true;
        } else if (a[mid] > target) {
          right = mid - 1;
        } else {
          left = mid + 1;
        }
      }
    
      return false;
    }
    ```

## <a id='Leetcode35：查找插入位置'>Leetcode35：查找插入位置</a>

[OJ链接](https://leetcode.com/problems/search-insert-position/description/)

给定一个排序数组和一个目标值，在数组中找到目标值，并返回其索引。如果目标值不存在于数组中，返回它将会被按顺序插入的位置。

你可以假设数组中无重复元素。

示例 1:

```
输入: [1,3,5,6], 5
输出: 2
```

示例 2:

```
输入: [1,3,5,6], 2
输出: 1
```

示例 3:

```
输入: [1,3,5,6], 7
输出: 4
```

示例 4:

```
输入: [1,3,5,6], 0
输出: 0
```

### 解答:

* 解法一：使用二分查找，由题意可知当目标数字再数组中存在是二分查找会返回数组下标，反之当目标数字再数组中不存在时返回`l`左边界值即可知插入位置：

  * ```c
    int searchInsert(int* nums, int numsSize, int target){
        int l = 0, r = numsSize - 1;
        while (l <= r) {
            int mid = (l + r) >> 1;
            if (nums[mid] < target) l = mid + 1;
            else if (nums[mid] > target) r = mid - 1;
            else return mid;
        } 
        return l;
    };
    ```

  * ```c
    //由题意分析可知我们只要nums[i]<目标值就像右找，当nums[i]>=目标值则向左找
    int searchInsert(int* nums, int numsSize, int target) {
        int head = -1, tail = numsSize - 1, mid;
        while (head < tail) {
            mid = (head + tail + 1) >> 1;
            if (nums[mid] < target) head = mid;
            else tail = mid - 1;
        }
        return head + 1;
    }
    ```

* 解法二：遍历查找

  * ```c
    int searchInsert(int* nums, int numsSize, int target) {
        for (int i = 0; i < numsSize; i++) {
    		if(nums[i] >= target) return i;
        }
        return numsSize;
    }
    ```

## <a id='Leetcode162：寻找峰值'>Leetcode162：寻找峰值</a>

[OJ链接](https://leetcode.com/problems/find-peak-element/description/)

峰值元素是指其值大于左右相邻值的元素。

给定一个输入数组`nums`，其中`nums[i] ≠ nums[i+1]`，找到峰值元素并返回其索引。

数组可能包含多个峰值，在这种情况下，返回任何一个峰值所在位置即可。

你可以假设`nums[-1] = nums[n] = -∞`。

示例1：

```
输入: nums = [1,2,3,1]
输出: 2
解释: 3 是峰值元素，你的函数应该返回其索引 2。
```

示例2：

```
输入: nums = [1,2,1,3,5,6,4]
输出: 1 或 5 
解释: 你的函数可以返回索引 1，其峰值元素为 2；
     或者返回索引 5， 其峰值元素为 6。
```

说明：

你的解法应该是O（logN）时间复杂度的

### 解答

* 解法一：线性查找

  遍历数组，对于每个元素，如果该元素的前一元素和后一元素都小于该元素，那么该元素是一个峰值，返回

  时间复杂度：O(n)

  空间复杂度：O(1)

* 二分查找

  * 如果中间元素比右边的元素小，意味着当前处于一个“升序”中，那么右边(不含当前元素)将会出现一个峰值

  * 如果中间元素比右边的元素大，意味着当前处于一个“降序”中，那么左边(包含当前元素)将会出现一个峰值

  * 如果中间元素等于右边的元素，那么无法减小区间（所以题目给出了nums[i]不等于nums[i+1]）使用上述判断一直减小区间，直到区间只有1个元素

  * 时间复杂度：O(logn)

  * 空间复杂度：O(1)

  * ```c
    int findPeakElement(int* nums, int numsSize){
        int l = 0, r = numsSize - 1;
        while (l < r) {
            int mid = (l + r) / 2;
            if (nums[mid] > nums[mid + 1]) {
                r = mid;
            } else if(nums[mid] < nums[mid + 1]) {
                l = mid + 1;
            } 
        }
        return l == r ? l : -1;
    }
    ```



## <a id='旋转数组的最小数字'>旋转数组的最小数字</a>

[OJ链接](https://www.nowcoder.com/practice/9f3231a991af4f55b95579b44b7a01ba?tpId=13&tqId=11159&tPage=1&rp=2&ru=%2Fta%2Fcoding-interviews&qru=%2Fta%2Fcoding-interviews%2Fquestion-ranking)

把一个数组最开始的若干个元素搬到数组的末尾，我们称之为数组的旋转。 输入一个非递减排序的数组的一个旋转，输出旋转数组的最小元素

例如数组`{3,4,5,1,2}`为`{1,2,3,4,5}`的一个旋转，该数组的最小值为`1`

NOTE：给出的所有元素都大于`0`，若数组大小为`0`，请返回`0`

- 解法一：二分法查找

  - ```c
    class Solution {
    public:
        int minNumberInRotateArray(vector<int> rotateArray) {
             int  l = 0, r = rotateArray.size() - 1;
                while (l < r) {
                    int mid = (l + r) >> 1;
                    if (rotateArray[l] < rotateArray[r]) return rotateArray[l];
                    else if (rotateArray[mid] > rotateArray[l]) l = mid + 1;
                    else if (rotateArray[mid] < rotateArray[r])r = mid;
                    else ++l;
                }
                return rotateArray[l];
        }
    };
    ```

- 解法二：先排序再输出,但因为数组已经有序所以用快排会浪费很大一部分时间

  - ```c
    class Solution {
    public:
        int minNumberInRotateArray(vector<int> rotateArray) {
    		sort(rotateArray.begin(), rotateArray.end());
            return rotateArray[0];
        }
    };
    ```

- 解法三：遍历

  - ```c
    class Solution {
    public:
        int minNumberInRotateArray(vector<int> rotateArray) {
            int i;
            for (i = 1; i < rotateArray.size(); i++) {
                if (rotateArray[i] < rotateArray[i - 1]) return rotateArray[i];
            }
            return rotateArray[i - 1];
        }
    };
    ```



## <a id='Leetcode4:寻找两个有序数组的中位数'>Leetcode4:寻找两个有序数组的中位数</a>

[OJ链接](https://leetcode.com/problems/median-of-two-sorted-arrays/description/)

给定两个大小为 m 和 n 的有序数组 nums1 和 nums2 。

请找出这两个有序数组的中位数。要求算法的时间复杂度为 O(log (m+n))

示例 1:

```
nums1 = [1, 3]
nums2 = [2]

中位数是 2.0
```

示例 2:

```
nums1 = [1, 2]
nums2 = [3, 4]

中位数是 (2 + 3)/2 = 2.5
```

### 解答

#### 1）归并

使用一个辅助数组，使用归并排序的合并方法将两个数组合并，排成一个按序排序的数组，然后求中值：

```c++
class Solution {                                                                         
    public:                                                                               
    double findMedianSortedArrays(vector<int>& nums1, vector<int>& nums2) {               
        int len1 = nums1.size(), len2 = nums2.size(), idx1 = 0, idx2 = 0, idx = 0;       
        vector<int> sum_arr(len1 + len2, 0);                                             
        while (idx1 != len1 && idx2 != len2) {                                           
            if (nums1[idx1] >= nums2[idx2]) {                                            
                sum_arr[idx++] = nums2[idx2++];                                           
            } else {                                                                     
                sum_arr[idx++] = nums1[idx1++];                                           
            }                                                                             
        }                                                                                 
        while (idx1 != len1) sum_arr[idx++] = nums1[idx1++];                             
        while (idx2 != len2) sum_arr[idx++] = nums2[idx2++];                             
        if ((len1 + len2) % 2) {   
            return sum_arr[(len1 + len2) / 2];                                           
        } else {                                                                         
            return (double)(sum_arr[(len1 + len2 - 1) / 2] + sum_arr[(len1 + len2) / 2]) / 2;  
        }                                                                                 
    }                                                                                     
};           
```



- **时间复杂度**：O(m + n)
- **空间复杂度**：O(m + n)

时间复杂度不满足题目要求，但是这种方法也能accept

#### 2）归并（不使用辅助空间）

还是使用归并排序合并的思想，但是不使用辅助数组，根据两个数组的大小判断中值的下标，然后归并过程中递增下标，直到到达中值的下标。这样可以避免使用额外空间

```
class Solution {                                                                         
    public:                                                                               
    double findMedianSortedArrays(vector<int>& nums1, vector<int>& nums2) {               
    int m = nums1.size();
    int n = nums2.size();
    int len = m + n;
    int left = -1, right = -1;
    int aStart = 0, bStart = 0;
    for (int i = 0; i <= len / 2; i++) {
        left = right;
        if (aStart < m && (bStart >= n || nums1[aStart] < nums2[bStart])) {
            right = nums1[aStart++];
        } else {
            right = nums2[bStart++];
        }
    }
    if ((len & 1) == 0)
        return (left + right) / 2.0;
    else
        return right;                                                                     
    }                                                                                     
};                                                                                       
```

- **时间复杂度**：O(m + n)
- **空间复杂度**：O(1)

时间复杂度不满足题目要求，但是这种方法也能accept

#### 3）二分法

要求O(log(m+n))的时间复杂度，那么必须使用二分法，那么如何进行二分？考虑将数组`num1`分为2部分`[part1,part3]`，将数组num2分为2部分`[part2,part4]`，然后假设`part1`包含`sz1`个元素，`part2`包含`sz2`个元素。那么我们肯定是要找到`part1`和`part2`，使得：

```
sz1+sz2 = len/2，len为两个数组总长
```

可以以`len/2`为长度总和，以`part1`为基准：

- 当`part1`变大时，`sz1`扩大，那么`sz2`必须减小，因此`part2`要减小
- 当`part1`变小时，`sz1`减小，那么`sz2`必须扩大，因此`part2`要扩大

现在问题是根据什么标准来扩大或减小`part1`？这里设4个变量：

1. `part1`中最右边的元素（即`part1`最大的元素）为`l1`
2. `part3`中最左边的元素（即`part3`最小的元素）为`r1`
3. `part2`中最右边的元素（即`part2`最大的元素）为`l2`
4. `part4`中最左边的元素（即`part4`最小的元素）为`r2`

由于`part1`和`part2`必须为数组`nums1`和`nums2`组成数组的前半部分，那么必须满足：

```
l1 <= r1（已经满足）
l1 <= r2
l2 <= r1
l2 <= r2（已经满足）
```

因此，可以根据中间两个条件是否满足来扩大或减小`part1`

```
class Solution {
public:
    double findMedianSortedArrays(vector<int>& nums1, vector<int>& nums2) {
        if(nums2.size() < nums1.size())
            return findMedianSortedArrays(nums2,nums1);
        
        int sz = nums1.size() + nums2.size();
        int sz1l = 0,sz1r = nums1.size();
        int sz1 = 0,sz2 = 0;
        while(sz1 <= nums1.size()){
            sz1 = (sz1l + sz1r) / 2;
            sz2 = sz / 2 - sz1; 
            int l1 = sz1 == 0 ? INT_MIN : nums1[sz1 - 1];
            int r1 = sz1 == nums1.size() ? INT_MAX : nums1[sz1];
            int l2 = sz2 == 0 ? INT_MIN : nums2[sz2 - 1];
            int r2 = sz2 == nums2.size() ? INT_MAX : nums2[sz2];
            //用INT_MIN保证l < r,用INT_MAX保证r > l
            if(l1 > r2)
                sz1r = sz1 - 1;
            else if(l2  > r1)
                sz1l = sz1 + 1;
            else{
            //到这里已经确保了l1 < r2, l2 < r1
                if(sz % 2 == 0){
                    l1 = l1 > l2 ? l1 : l2;
                    r1 = r1 < r2 ? r1 : r2;
                    return (double)(l1 + r1) / 2;
                }
                else{
                    r1 = r1 < r2 ? r1 : r2;
                    return r1;
                }
            }
                
        }
        
        return -1;
    }
};
```

- **时间复杂度**：O(log(min(m,n)))
- **空间复杂度**：O(1)

## <a id='const小点'>const小点</a>

```c++
int b = 500;
1.const int *a = &b;
2.int const *a = &b;
3.int * const a = &b;
4.const int* const a = &b;

```





