# 算法题总结

## 目录

* **一、数组**
  * 数组操作
  * 二维数组
  * 子数组与连续数组
  * 排列组合
  * 排序
  * 二分查找
    * Leetcode35：[查找插入位置](#Leetcode35：查找插入位置)（`二分查找` `easy`）
    * 《剑指offer》面试题11：[旋转数组的最小数字](旋转数组的最小数字)（`二分查找`）
    * Leetcode33：[旋转数组中查找数字](Leetcode33：旋转数组中查找数字)（`二分查找` `medium`）
  * 其他查找
  * 场景模拟
* **二、字符串**
* **三、栈和队列**
* **四、链表**
* **五、树**
* **六、数学**
* **七、图**
* **八、设计模式**
* **九、海量数据**
* **十、C\C++基础**

## <a id='Leetcode33：旋转数组中查找数字'>Leetcode33：旋转数组中查找数字</a>

[OJ链接](https://leetcode.com/problems/search-in-rotated-sorted-array/description/)

假设按照升序排序的数组在预先未知的某个点上进行了旋转。

( 例如，数组 `[0,1,2,4,5,6,7]` 可能变为 `[4,5,6,7,0,1,2]` )。

搜索一个给定的目标值，如果数组中存在这个目标值，则返回它的索引，否则返回 `-1` 。

你可以假设数组中不存在重复的元素。

你的算法时间复杂度必须是 O(log n) 级别。

示例 1:

```
输入: nums = [4,5,6,7,0,1,2], target = 0
输出: 4
```

示例 2:

```
输入: nums = [4,5,6,7,0,1,2], target = 3
输出: -1
```

* 解法一

  * 首先，如果`nums[mid] == target`，那么找到目标元素，返回`mid`

  * `如果nums[l] < nums[r]`，说明`l~r`范围的元素有序，那么执行正常的二分查找

  * 否则，根据`mid`位置的值判断`mid`是在左半部分还是右半部分

    - 如果`nums[mid] ≥ nums[l]`，说明`mid`在左半部分
      - 当`target > nums[r] && target < nums[mid]`，那么`target`只可能出现在`mid`的左边，因此在`mid`左边继续查找
      - 否则，`target`只可能出现在`mid`的右边，因此在`mid`右边继续查找

    - 否则，`mid`在右半部分
      - 当`target > nums[mid] && target < nums[l]`，那么`target`只可能出现在`mid`的右边，因此在`mid`右边继续查找
      - 否则，`target`只可能出现在`mid`的左边，因此在`mid`左边继续查找

  * ```c
    int search(int* nums, int numsSize, int target) {
        int l = 0, r = numsSize - 1;
        while (l <= r) {
            int mid = (l + r) >> 1;
            if (nums[mid] == target) return mid;
            if (nums[l] < nums[r]) {
                if (nums[mid] > target) {
                    r = mid - 1;
                }   else {
                    l = mid + 1;
                }
            } else {
                if (nums[mid] >= nums[l]) {
                    if (nums[mid] > target && target > nums[r]) {
                        r = mid - 1;
                    } else {
                        l = mid + 1;
                    }
                } else {
                    if (nums[mid] < target && target < nums[l]) {
                        l = mid + 1;
                    } else {
                        r = mid - 1;
                    }
                }
            }
        }
        return -1;
    }
    ```

  * 

* 解法二

  ```c++
  class Solution {
  public:
      int search(vector<int>& nums, int target) {
          int lo = 0, hi = nums.size() - 1;
          while (lo < hi) {
              int mid = (lo + hi) / 2;
              if ((nums[0] > target) ^ (nums[0] > nums[mid]) ^ (target > nums[mid]))
                  lo = mid + 1;
              else
                  hi = mid;
          }
          return lo == hi && nums[lo] == target ? lo : -1;
      }
  };
  ```

  

* 

## <a id='Leetcode35：查找插入位置'>Leetcode35：查找插入位置</a>

[OJ链接](https://leetcode.com/problems/search-insert-position/description/)

给定一个排序数组和一个目标值，在数组中找到目标值，并返回其索引。如果目标值不存在于数组中，返回它将会被按顺序插入的位置。

你可以假设数组中无重复元素。

示例 1:

```
输入: [1,3,5,6], 5
输出: 2
```

示例 2:

```
输入: [1,3,5,6], 2
输出: 1
```

示例 3:

```
输入: [1,3,5,6], 7
输出: 4
```

示例 4:

```
输入: [1,3,5,6], 0
输出: 0
```

### 解答:

* 解法一：使用二分查找，由题意可知当目标数字再数组中存在是二分查找会返回数组下标，反之当目标数字再数组中不存在时返回`l`左边界值即可知插入位置：

  * ```c
    int searchInsert(int* nums, int numsSize, int target){
        int l = 0, r = numsSize - 1;
        while (l <= r) {
            int mid = (l + r) >> 1;
            if (nums[mid] < target) l = mid + 1;
            else if (nums[mid] > target) r = mid - 1;
            else return mid;
        } 
        return l;
    };
    ```

  * ```c
    //由题意分析可知我们只要nums[i]<目标值就像右找，当nums[i]>=目标值则向左找
    int searchInsert(int* nums, int numsSize, int target) {
        int head = -1, tail = numsSize - 1, mid;
        while (head < tail) {
            mid = (head + tail + 1) >> 1;
            if (nums[mid] < target) head = mid;
            else tail = mid - 1;
        }
        return head + 1;
    }
    ```

* 解法二：遍历查找

  * ```c
    int searchInsert(int* nums, int numsSize, int target) {
        for (int i = 0; i < numsSize; i++) {
    		if(nums[i] >= target) return i;
        }
        return numsSize;
    }
    ```

## <a id='旋转数组的最小数字'>旋转数组的最小数字</a>

[OJ链接](https://www.nowcoder.com/practice/9f3231a991af4f55b95579b44b7a01ba?tpId=13&tqId=11159&tPage=1&rp=2&ru=%2Fta%2Fcoding-interviews&qru=%2Fta%2Fcoding-interviews%2Fquestion-ranking)

把一个数组最开始的若干个元素搬到数组的末尾，我们称之为数组的旋转。 输入一个非递减排序的数组的一个旋转，输出旋转数组的最小元素

例如数组`{3,4,5,1,2}`为`{1,2,3,4,5}`的一个旋转，该数组的最小值为`1`

NOTE：给出的所有元素都大于`0`，若数组大小为`0`，请返回`0`

- 解法一：二分法查找

  - ```c
    class Solution {
    public:
        int minNumberInRotateArray(vector<int> rotateArray) {
             int  l = 0, r = rotateArray.size() - 1;
                while (l < r) {
                    int mid = (l + r) >> 1;
                    if (rotateArray[l] < rotateArray[r]) return rotateArray[l];
                    else if (rotateArray[mid] > rotateArray[l]) l = mid + 1;
                    else if (rotateArray[mid] < rotateArray[r])r = mid;
                    else ++l;
                }
                return rotateArray[l];
        }
    };
    ```

- 解法二：先排序再输出,但因为数组已经有序所以用快排会浪费很大一部分时间

  - ```c
    class Solution {
    public:
        int minNumberInRotateArray(vector<int> rotateArray) {
    		sort(rotateArray.begin(), rotateArray.end());
            return rotateArray[0];
        }
    };
    ```

- 解法三：遍历

  - ```c
    class Solution {
    public:
        int minNumberInRotateArray(vector<int> rotateArray) {
            int i;
            for (i = 1; i < rotateArray.size(); i++) {
                if (rotateArray[i] < rotateArray[i - 1]) return rotateArray[i];
            }
            return rotateArray[i - 1];
        }
    };
    ```













