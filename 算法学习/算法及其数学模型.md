# 算法及其数学模型

## 1.自然数与整数

首先，让我们先来回顾一下自然数与整数的基本知识

**自然数**，也叫作正整数，就是所谓的：

１，２，３，４，５，.....,ｎ，ｎ＋１...			（１）

我们以**Ｎ**表示全体自然数（1）所组成的集合，整数就是指正整数、负整数和０组成的集合**Z**

**在正整数中不一定能做加法运算的逆运算－－减法运算**

**在整数集合中可以做乘法运算，但不一定可作乘法运算的逆运算－－除法运算**

｜ａ　＋　ｂ｜<= |a| + |b|	

## 2.整除理论

**设对于整数ｂ，ｄ１，ｄ２，....ｄｋ是他的全体约数，那么b/d1,b/d2,.....b/dk也是他的全体约数，也就是说当ｄ遍历ｂ的全体约数时，ｂ/d也遍历ｂ的全体约数**

所以我们可以在某些算法中只遍历一半的参数达到遍历全体的目的。

## 2.2素数和合数

对于一个整数b$\neq$0, $\pm$1且他除了显然约数$\pm$1、$\pm$p外没有其他约数，那么ｐ就称为**不可约数**，也叫**素数**,

若ａ$\neq$0,$\pm$1,且不是不可约数，则ａ是**合数**

**定理１：如果一个整数ａ>=2，那么ａ一定可以表示为不可约数的乘积（包括ａ本身是不可约数）**

**a = p~1~p~2~...p~s~**

**定理２：设ａ>=２则：**

**(1)若ａ是合数，则必有不可约数ｐ｜ａ，ｐ<=ａ^1/2^**

**(2)若ａ有定理１中表达式，则必有不可约数ｐ｜ａ，ｐ<=a^1/s^(其中ｓ为不可约数的定理１中个数)**

例：当a = 1260时，１２６０　＝　２＊２＊３＊３＊５＊７（ｓ　＝　６）

​	２ < (1260)^1/6^$\approx$3.28

所以由定理２(1)提出了两种种筛选素数的有效算法：

```c
#include <stdio.h>
#define MAX 10000
int prime[MAX + 5] = {0};
void init() {
    for (int i = 2; i * i < n; i++) {
        if(prime[i]) continue;
        //关于ｊ的初值如果设为j * 2则会在遍历的过程中会重复标记某个数，x×x设定为初值会保证j的初值必定为第一个由自身标定的合数
        for (int j = i * 2; j < MAX; j += i) { //for (int j = i * i; j < MAX; j += i)
			prime[j] = 1;
        }
    }
    return;
}
```

```c
#include <stdio.h>
#define MAX 10000
int prime[MAX + 5] = {0};
void init() {
}
```



## 2.最大公因数（*gcd*）

[数学](https://zh.wikipedia.org/wiki/%E6%95%B0%E5%AD%A6)中，两个或多个[整数](https://zh.wikipedia.org/wiki/%E6%95%B4%E6%95%B8)的**最大公约数**（英语：greatest common factor，hcf）指能够[整除](https://zh.wikipedia.org/wiki/%E6%95%B4%E9%99%A4)这些整数的最大正整数（这些整数不能都为零）。例如8和12的最大公因数为4。最大公因数也称**最大公约数**（英语：greatest common divisor，gcd）。 

整数序列      ![a](https://wikimedia.org/api/rest_v1/media/math/render/svg/ffd2487510aa438433a2579450ab2b3d557e5edc)的最大公因数可以记为。 

求两个整数最大公约数主要的方法： 

- [穷举法](https://zh.wikipedia.org/wiki/%E7%AA%AE%E8%88%89%E6%B3%95)：分别列出两整数的所有约数，并找出最大的公约数。

- [素因数分解](https://zh.wikipedia.org/wiki/%E8%B3%AA%E5%9B%A0%E6%95%B8%E5%88%86%E8%A7%A3)：分别列出两数的素因数分解式，并计算共同项的[乘积](https://zh.wikipedia.org/wiki/%E4%B9%98%E7%A7%AF)。

- [短除法](https://zh.wikipedia.org/wiki/%E7%9F%AD%E9%99%A4%E6%B3%95)：两数除以其共同[素因数](https://zh.wikipedia.org/wiki/%E8%B3%AA%E5%9B%A0%E6%95%B8)，直到两数[互素](https://zh.wikipedia.org/wiki/%E4%BA%92%E8%B3%AA)时，所有除数的乘积即为最大公约数。

- [辗转相除法](https://zh.wikipedia.org/wiki/%E8%BC%BE%E8%BD%89%E7%9B%B8%E9%99%A4%E6%B3%95)：两数相除，取余数重复进行相除，直到余数为   ![{\displaystyle 0}](https://wikimedia.org/api/rest_v1/media/math/render/svg/2aae8864a3c1fec9585261791a809ddec1489950)时，前一个除数即为最大公约数。

  

#### 重点：欧几里得算法（辗转相除法）

```c
int gcd (int a, int b) {
    if (b > a) return gcd(b, a);
    if (a % b == 0) return b;
    return gcd(b, a % b);
}
```



在[直角坐标](https://zh.wikipedia.org/wiki/%E7%9B%B4%E8%A7%92%E5%9D%90%E6%A0%87)中，两顶点为![{\displaystyle (0,0),(a,b)}](https://wikimedia.org/api/rest_v1/media/math/render/svg/78b8c287844a928bb627328195c697cfe34a5f95)的线段会通过  ![{\displaystyle \gcd(a,b)+1}](https://wikimedia.org/api/rest_v1/media/math/render/svg/c3f4c81f1cf043e68c10626098accae9b0a736b0)个[格子点](https://zh.wikipedia.org/w/index.php?title=%E6%A0%BC%E5%AD%90%E9%BB%9E&action=edit&redlink=1)。 

#### **延伸：最小公倍数（*lcm*）**

**最小公倍数**是[数论](https://zh.wikipedia.org/wiki/%E6%95%B0%E8%AE%BA)中的一个概念。若有一个数X，可以被另外两个数A、B整除，且X大于（或等于）A和B，则X为A和B的公倍数。

对[分数](https://zh.wikipedia.org/wiki/%E5%88%86%E6%95%B8)进行加减运算时，要求两数的分母相同才能计算，故需要通分；标准的计算步骤是将两个分数的分母通分成它们的最小公倍数，然后将通分后的分子相加。 

**两个整数的最小公倍数与最大公因数之间有如下的关系： **

**lcm(a,b) =$\frac{|a * b|}{gcd(a,b)}$**

最小公倍数的适用范围：分数的加减法，中国剩余定理(正确的题在最小公倍数内有解，有唯一的解)。 [2]  因为，素数是不能被1和自身数以外的其它数整除的数；素数X的N次方，是只能被X的N及以下次方，1和自身数整除。所以，给最小公倍数下一个定义：S个数的最小公倍数，为这S个数中所含素因子的最高次方之间的乘积。

**例如**：1，求756，4400，19845，9000的最小公倍数？

因756=2*2*3*3*3*7，4400=2*2*2*2*5*5*11，19845=3*3*3*3*5*7*7，9000=2*2*2*3*3*5*5*5，这里有素数2，3，5，7，11．2最高为4次方16，3最高为4次方81，5最高为3次方125，7最高为2次方49，还有素数11。得最小公倍数为16*81*125*49*11=87318000．2，自然数1至50的最小公倍数，因为，√50≈7，所以，在50之内的数只有≤7的素数涉及N次方。在50之内，2的最高次方的数为32，3的最高次方的数为27，5的最高次方的数为25，7的最高次方的数为49，其余为50之内的素数。所以，1，2，3，4，5，6，…，50的最小公倍数为：32*27*25*49*11*13*17*19*23*29*31*37*41*43*47=3099044504245996706400

## 3.同余定理

